package com.flyingsloth.financial.data;

import HTTPUtil.HTTPRequestPoster;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.io.StringWriter;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.Date;
import java.util.Collection;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringEscapeUtils;


public class YahooDataSource extends AssetHistorySource {
	
	static YahooPriceData getPrice(String symbol, String year, String month, String date ) throws ParsingFailedException
	{
		//String symbol = "MCD";
		//String month = "1"; // Jan = 00
		//String date = "2";
		//String year = "1970";
		
		String response = HTTPRequestPoster.sendGetRequest("http://finance.yahoo.com/q/hp", "s=" + symbol + "&a=" + month + "&b=" + date + "&c=" + year + "&d=" + month + "&e=" + date + "&f=" + year + "&g=d" );
//		String response = HTTPRequestPoster.sendGetRequest("http://llwww", "" );		
//		System.out.println( response );
		
		// Pull out the price table from the HTML code
		Pattern regex_pricetable_HTML = Pattern.compile( "<table[^<>]*?><tr[^<>]*?><th[^<>]*?>Date</th>.*?<th[^<>]*?>Open</th>.*?<th[^<>]*?>High</th>.*?<th[^<>]*?>Low</th>.*?<th[^<>]*?>Close</th>.*?</tr>" 
				+ "<tr[^<>]*>" + "<td[^<>]*>([^<>]*)</td>" + "<td[^<>]*>([^<>]*)</td>" + "<td[^<>]*>([^<>]*)</td>" + "<td[^<>]*>([^<>]*)</td>" + "<td[^<>]*>([^<>]*)</td>" + ".*?</table>" ); 
		Matcher matches = regex_pricetable_HTML.matcher(response);
		if( !matches.find() )
			throw new ParsingFailedException();
		
		YahooPriceData result = new YahooPriceData();
		result.Open = Double.parseDouble(matches.group(2));
		result.High = Double.parseDouble(matches.group(3));
		result.Low = Double.parseDouble(matches.group(4));
		result.Close = Double.parseDouble(matches.group(5));
		return result;
	}

    public static Collection<DateDouble> getClosingPrices( String symbol )
    throws java.text.ParseException, NumberFormatException, IOException {
//    	System.out.println( "Retriving prices for:  " + symbol );
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&g=d&ignore=.csv");
    	return getClosingPrices( url,  365*(10) );    	
    }    

    private static String dateFilterString( Date start, Date end )
    {
    	return "d=" + end.getMonth() + "&e=" + end.getDate() + "&f=" + (end.getYear()+1900) +  "&a=" + start.getMonth() + "&b=" + start.getDate() + "&c=" + (start.getYear()+1900); 
    }
    
    // Returns a vector of historical closing prices, starting with the most recent
    public static Collection<DateDouble> getClosingPrices( String symbol, Date start, Date end ) throws IOException, NumberFormatException, ParseException {    	
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&" + dateFilterString( start, end ) + "&g=d&ignore=.csv");
    	return getClosingPrices( url,  365*(end.getYear()-start.getYear()+1) );
    }

    // Parse the csv file of prices that Yahoo finance returns
    private static Collection<DateDouble> getClosingPrices( URL url, int numEntriesGuess ) throws IOException, NumberFormatException, ParseException {
    	try
    	{
    	URLConnection conn = url.openConnection();
    	conn.setConnectTimeout(5000);
    	conn.setReadTimeout(5000);

    	// Get the response
    	BufferedReader tablein = new BufferedReader( new InputStreamReader(conn.getInputStream()) );

    	
    	ArrayList<DateDouble> closeprices = new ArrayList<DateDouble>( numEntriesGuess );
    	
    	    	
    	DateFormat dateparser = new SimpleDateFormat( "yyyy-MM-dd" );
    	
    	String line = tablein.readLine(); // header
    	line = tablein.readLine();
    	while( line != null )
    	{
    		// Close price is between 4th and 5th comma
    		int fc = line.indexOf(',');
    		int lc = line.indexOf(',', line.indexOf(',', line.indexOf(',',fc+1)+1)+1);
    		int rc = line.indexOf(',', lc+1);
    		closeprices.add( new DateDouble( dateparser.parse(line.substring(0,fc)), Double.parseDouble(line.substring(lc+1, rc)) ) );
    		
    		line = tablein.readLine();
    	}
    	return closeprices;  
    	}
    	catch( java.net.SocketTimeoutException e )
    	{
    		// Pass through failures to reach the server
    		throw e;
    	}
    	catch( IOException e )
    	{
    		// If the symbol simply wasn't found on the server, return empty data structure
    		return new ArrayList<DateDouble>(0);
    	}
    }
    
    public static AssetHistory getAllPrices( String symbol )
    throws java.text.ParseException, NumberFormatException, MalformedURLException, SocketTimeoutException {    	
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&g=d&ignore=.csv");
    	AssetHistory res = getAllPrices( url,  365*(10) );
    	res.symbol = symbol;
    	return res;
    }    

    // Returns a vector of historical closing prices, starting with the most recent
    public static AssetHistory getAllPrices( String symbol, Date start, Date end ) throws IOException, NumberFormatException, ParseException {    	
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&" + dateFilterString( start, end ) + "&g=d&ignore=.csv");
    	AssetHistory res = getAllPrices( url,  365*(end.getYear()-start.getYear()+1) );
    	res.symbol = symbol;
    	return res;
    }

    // Parse the csv file of prices that Yahoo finance returns
    private static AssetHistory getAllPrices( URL url, int numEntriesGuess ) throws NumberFormatException, ParseException, SocketTimeoutException {
    	//System.err.println( "getAllPrices: retriving prices" );

    	ArrayList<Date> dates = new ArrayList<Date>( numEntriesGuess );
    	ArrayList<Float> openprices = new ArrayList<Float>( numEntriesGuess );
    	ArrayList<Float> highprices = new ArrayList<Float>( numEntriesGuess );
    	ArrayList<Float> lowprices = new ArrayList<Float>( numEntriesGuess );
    	ArrayList<Float> closeprices = new ArrayList<Float>( numEntriesGuess );
    	ArrayList<Integer> volumes = new ArrayList<Integer>( numEntriesGuess );
    	
    	try
    	{    		
    	//System.err.println( "getAllPrices: connecting to URL");
    	URLConnection conn = url.openConnection();
    	conn.setConnectTimeout(5000);
    	conn.setReadTimeout(5000);

    	// Get the response
    	BufferedReader tablein = new BufferedReader( new InputStreamReader(conn.getInputStream()) );    	
    	    	    	
    	DateFormat dateparser = new SimpleDateFormat( "yyyy-MM-dd" );
    	
    	String line = tablein.readLine(); // header
    	line = tablein.readLine();
    	int[] comma_idx = new int[6];
    	while( line != null )
    	{
    		// Close price is between 4th and 5th comma
    		comma_idx[0] = line.indexOf(',');
    		for( int i = 1; i < comma_idx.length; ++i )
    		{
    			comma_idx[i] = line.indexOf(',', comma_idx[i-1]+1);
    		}
    		dates.add( dateparser.parse(line.substring(0,comma_idx[0]) ));
    		openprices.add( Float.parseFloat(line.substring(comma_idx[0]+1,comma_idx[1])));
    		highprices.add( Float.parseFloat(line.substring(comma_idx[1]+1,comma_idx[2])));
    		lowprices.add( Float.parseFloat(line.substring(comma_idx[2]+1,comma_idx[3])));
    		closeprices.add( Float.parseFloat(line.substring(comma_idx[3]+1,comma_idx[4])));
    		volumes.add( Integer.parseInt(line.substring(comma_idx[4]+1,comma_idx[5])));
    		    		
    		line = tablein.readLine();
    	}
    
    	}
    	catch( java.net.SocketTimeoutException e )
    	{
    		// Pass through failures to reach the server
        	System.err.println( "getAllPrices: SocketTimeoutException");    		
    		throw e;
    	}
    	catch( IOException e )
    	{
    		// If the symbol simply wasn't found on the server, return empty data structure
        	System.err.println( "getAllPrices: IOException");
    	}
    	
    	AssetHistory hist = new AssetHistory();
    	hist.date = dates.toArray(new Date[0]);
    	//hist.open =  ArrayUtils.toPrimitive(openprices.toArray(new Float[0]));
    	hist.open = ArrayUtils.toPrimitive(openprices.toArray(new Float[0]));
    	hist.high = ArrayUtils.toPrimitive(highprices.toArray(new Float[0]));
    	hist.low =  ArrayUtils.toPrimitive(lowprices.toArray(new Float[0]));
    	hist.close =  ArrayUtils.toPrimitive(closeprices.toArray(new Float[0]));
    	hist.volume = ArrayUtils.toPrimitive(volumes.toArray(new Integer[0]));
    	return hist;
    }
    
    public static Collection<DateDouble> getDividends( String symbol )
    throws java.text.ParseException, NumberFormatException, MalformedURLException, SocketTimeoutException {
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&g=v&ignore=.csv");
    	return getDividends( url, 128 );
    }
    
    public static Collection<DateDouble> getDividends( String symbol, Date start, Date end ) throws NumberFormatException, ParseException, MalformedURLException, SocketTimeoutException {
    	URL url = new URL("http://ichart.finance.yahoo.com/table.csv?s=" + symbol + "&" + dateFilterString( start, end ) + "&g=v&ignore=.csv");
    	return getDividends( url, 4*(end.getYear()-start.getYear()+1) );
    }
    
    private static Collection<DateDouble> getDividends( URL url, int numEntriesGuess) throws NumberFormatException, ParseException, SocketTimeoutException {
    	//System.err.println( "getDividends: getting dividends" );
    	try
    	{
    	URLConnection conn = url.openConnection();
    	conn.setConnectTimeout(5000);
    	conn.setReadTimeout(5000);

    	// Get the response
    	BufferedReader tablein = new BufferedReader( new InputStreamReader(conn.getInputStream()) );

    	
    	ArrayList<DateDouble> divlist = new ArrayList<DateDouble>( numEntriesGuess );
    	    	
    	DateFormat dateparser = new SimpleDateFormat( "yyyy-MM-dd" );
    	
    	String line = tablein.readLine(); // header
    	line = tablein.readLine();
    	while( line != null )
    	{
    		// Close price is between 4th and 5th comma
    		int lc = line.indexOf(',');
    		
    		divlist.add( new DateDouble( dateparser.parse(line.substring(0,lc)) , Double.parseDouble(line.substring(lc+1)) ) );
    		
    		line = tablein.readLine();
    	}
    	return divlist;
    	}
    	catch( java.net.SocketTimeoutException e )
    	{
    		// Pass through failures to reach the server
    		throw e;
    	}
    	catch( IOException e )
    	{
    		// If the symbol simply wasn't found on the server, return empty data structure
    		return new ArrayList<DateDouble>(0);
    	}

    }
    
    public static Collection<DateDouble> getSplits( String symbol ) throws NumberFormatException, SocketTimeoutException, MalformedURLException, ParseException
    {
    	return getSplits( new URL("http://finance.yahoo.com/q/hp?s=" + symbol + "&g=v") );
    }
    
    public static Collection<DateDouble> getSplits( String symbol, Date start, Date end ) throws NumberFormatException, SocketTimeoutException, MalformedURLException, ParseException
    {
    	return getSplits( new URL("http://finance.yahoo.com/q/hp?s=" + symbol + "&g=v&" + dateFilterString( start, end )) ); 
    }
    
    // Used in getSplits() and anything else that uses human readable Yahoo finance pages
    private static final Pattern next_link_patt = Pattern.compile( "<a[^<>]*?href=\"[^<>\"]*?\\?([^<>\"]*?)\"[^<>]*?>Next</a>" );
    
    private static Collection<DateDouble> getSplits( URL url ) throws NumberFormatException, ParseException, SocketTimeoutException {
    	try
    	{
	    	URLConnection conn = url.openConnection();
	    	conn.setConnectTimeout(5000);
	    	conn.setReadTimeout(5000);
	
	    	// Get the response
	    	String htmlsrc = IOUtils.toString(conn.getInputStream(), conn.getContentEncoding() );
	    	
	    	Collection<DateDouble> results = parseYahooSplits( htmlsrc );
	    	
	    	// Is there more?    	
			// Whether the text "Next' is in a <span> tag or an <a> tag tells us whether there are
			// more prices on the next page		    
			Matcher m = next_link_patt.matcher(htmlsrc);
			boolean are_more_prices = m.find();
			while( are_more_prices )
			{
				// Replace HTML special entities (e.g. &amp) in the link to the next page
				String nxtquery = StringEscapeUtils.unescapeHtml4(m.group(1));
				URL nxturl = new URL( "http://finance.yahoo.com/q/hp?" + nxtquery );
				conn = nxturl.openConnection();
		    	conn.setConnectTimeout(5000);
		    	conn.setReadTimeout(5000);		    	
				htmlsrc = IOUtils.toString(conn.getInputStream(), conn.getContentEncoding() );
				results.addAll(parseYahooSplits( htmlsrc ));
				m = next_link_patt.matcher(htmlsrc);
				are_more_prices = m.find();
			}
			return results;
    	}
    	catch( java.net.SocketTimeoutException e )
    	{
    		// Pass through failures to reach the server
    		throw e;
    	}
    	catch( IOException e )
    	{
    		// If the symbol simply wasn't found on the server, return empty data structure
    		return new ArrayList<DateDouble>(0);
    	}

    }    
    
    // Slower approach: parse human readable HTML
    private static Collection<DateDouble> parseYahooDividends( String htmlsrc ) 
	throws java.text.ParseException {
		//System.out.println( htmlsrc );
		Pattern dividend_patt = Pattern.compile(
				"<tr><td[^<>]*?>([^<>]*?)</td><td[^<>]*?>([0-9.]+) Dividend</td></tr>"
				);
		Matcher m = dividend_patt.matcher(htmlsrc);
		ArrayList<DateDouble> results = new ArrayList<DateDouble>();
		DateFormat dateparser = new SimpleDateFormat( "MMM dd, yyyy" );
		while( m.find() )
		{
			//System.out.println( m.group() );
			//System.out.println( m.group(1) );
			//System.out.println( m.group(2) );
			results.add( new DateDouble( dateparser.parse(m.group(1)), Double.parseDouble(m.group(2)) ) );
		}
				
		return results;
	}
    
    // Slower approach: parse human readable HTML
    private static Collection<DateDouble> parseYahooSplits( String htmlsrc ) 
	throws java.text.ParseException {
		//System.out.println( htmlsrc );
		Pattern dividend_patt = Pattern.compile(
				"<tr><td[^<>]*?>([^<>]*?)</td><td[^<>]*?>([0-9.]+)[ \t\n]*:[ \t\n]*([0-9.]+) Stock Split</td></tr>"
				);
		Matcher m = dividend_patt.matcher(htmlsrc);
		ArrayList<DateDouble> results = new ArrayList<DateDouble>();
		DateFormat dateparser = new SimpleDateFormat( "MMM dd, yyyy" );
		while( m.find() )
		{
			//System.out.println( m.group() );
			//System.out.println( m.group(1) );
			//System.out.println( m.group(2) );
			results.add( new DateDouble( dateparser.parse(m.group(1)), Double.parseDouble(m.group(2))/Double.parseDouble(m.group(3)) ) );
		}
				
		return results;
	}    
	
    // Slower approach: parse human readable HTML
	private static Collection<DateDouble> parseYahooClosingPrices( String htmlsrc ) 
	throws java.text.ParseException {
		//System.out.println( htmlsrc );
		Pattern dividend_patt = Pattern.compile(
				"<tr[^<>]*>" + "<td[^<>]*>([^<>]*)</td>" + "<td[^<>]*>([0-9.]+)</td>" + "<td[^<>]*>([0-9.]+)</td>" + "<td[^<>]*>([0-9.]+)</td>" + "<td[^<>]*>([0-9.]+)</td>" + "<td[^<>]*>([0-9,]+)</td>" + "<td[^<>]*>([0-9.]+)</td>" + "</tr>" 
				);
		Matcher m = dividend_patt.matcher(htmlsrc);
		ArrayList<DateDouble> results = new ArrayList<DateDouble>();
		DateFormat dateparser = new SimpleDateFormat( "MMM dd, yyyy" );
		while( m.find() )
		{
			//System.out.println( m.group() );
			//System.out.println( m.group(1) );
			//System.out.println( m.group(2) );
			results.add( new DateDouble( dateparser.parse(m.group(1)), Double.parseDouble(m.group(5)) ) );
		}
				
		return results;
	}	
	
	
	public static Date getInitialDate( String symbol ) throws ParsingFailedException
	{
		// Bring up the Yahoo Finance Historical Prices page
		// and see what start date it puts in by default
		String response = HTTPRequestPoster.sendGetRequest("http://finance.yahoo.com/q/hp","s=" + symbol + "+Historical+Prices");
		//System.out.println( response );
		
		// Start Month (eg March=02):  <select name="a" id="selstart"><option value="00">Jan</option>...<option selected value="02">
		// Start Day (eg 13): <input type="text" name="b" id="startday" size="2" maxlength="2" value="13">
		// Start Year (eg 1986): <input type="text" name="c" id="startyear" size="4" maxlength="4" value="1986"> 
		
		Pattern regex_pricetable_HTML = Pattern.compile( 
				"<select [^<>]*?id=\"selstart\"[^<>]*?>.*?" + 
				"<option selected value=\"([0-9]+)\">" + ".*?" + 
				"<input[^<>]*?id=\"startday\"[^<>]*?value=\"([0-9]+)\">" + ".*?" + 
				"<input[^<>]*?id=\"startyear\"[^<>]*?value=\"([0-9]+)\">" ); 
		Matcher matches = regex_pricetable_HTML.matcher(response);
		if( !matches.find() )
			throw new ParsingFailedException();
		
//		System.out.println(matches.group());
//		System.out.println(matches.group(1));
//		System.out.println(matches.group(2));
//		System.out.println(matches.group(3));
		
		Calendar result = new GregorianCalendar();
		result.set( Integer.parseInt(matches.group(3)), Integer.parseInt(matches.group(1)), Integer.parseInt(matches.group(2)) );
		
		return result.getTime();
	}
	
	
	public AssetHistory getAsset( String symbol ) throws NumberFormatException, ParseException, MalformedURLException, SocketTimeoutException {
		AssetHistory res = getAllPrices( symbol );
		
		Collection<DateDouble> datedivs = getDividends(symbol);
		
		//res.dividends = new double[res.date.length];
		//Arrays.fill(res.dividends, 0.0);
		res.normalize();
		
		//System.err.println( "Inserting dividend records" );
		for( DateDouble dd : datedivs )
		{
			// Find the entry in the existing date vector (the one from reading the price table) 
			// that contains the date of this dividend.
			// Note that date array is expected to be reverse order, with most recent date first
			int idx = Arrays.binarySearch(res.date, dd.date, new Comparator<Date>() { 
																public int compare( Date d1, Date d2 ) {
																	return d2.compareTo(d1);
																}
														});
			if( idx < 0 )
				res.insert(dd.date, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, dd.value, 1.0);
			else
				res.setDividend( idx, dd.value );
		}
		
		Collection<DateDouble> datesplits = getSplits(symbol);
		for( DateDouble dd : datesplits )
		{
			int idx = Arrays.binarySearch(res.date, dd.date, new Comparator<Date>() { 
																public int compare( Date d1, Date d2 ) {
																	return d2.compareTo(d1);
																}
														});
			if( idx < 0 )
				res.insert(dd.date, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, 0.0, dd.value);
			else
				res.split[idx] = dd.value;
		}
		
		return res;
	}

	public AssetHistory getAsset( String symbol, Date start, Date end) throws NumberFormatException, IOException, ParseException
	{
		AssetHistory res = getAllPrices( symbol, start, end );
		
		Collection<DateDouble> datedivs = getDividends(symbol, start, end);
		
		//res.dividends = new double[res.date.length];
		//Arrays.fill(res.dividends, 0.0);
		res.normalize();
		
		//System.err.println( "Inserting dividend records" );
		for( DateDouble dd : datedivs )
		{
			// Find the entry in the existing date vector (the one from reading the price table) 
			// that contains the date of this dividend.
			// Note that date array is expected to be reverse order, with most recent date first
			int idx = Arrays.binarySearch(res.date, dd.date, new Comparator<Date>() { 
																public int compare( Date d1, Date d2 ) {
																	return d2.compareTo(d1);
																}
														});
			if( idx < 0 )
				res.insert(dd.date, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, dd.value, 1.0);
			else
				res.setDividend( idx, dd.value );
		}
		
		Collection<DateDouble> datesplits = getSplits(symbol, start, end);
		for( DateDouble dd : datesplits )
		{
			int idx = Arrays.binarySearch(res.date, dd.date, new Comparator<Date>() { 
																public int compare( Date d1, Date d2 ) {
																	return d2.compareTo(d1);
																}
														});
			if( idx < 0 )
				res.insert(dd.date, Float.NaN, Float.NaN, Float.NaN, Float.NaN, 0, 0.0, dd.value);
			else
				res.split[idx] = dd.value;
		}
		
		return res;		
	}
}
