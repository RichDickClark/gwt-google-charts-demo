package edu.mit.ll.williams.hmm.test;

import java.io.Serializable;
import java.util.ArrayList;

import edu.mit.ll.williams.hmm.FullHiddenMarkovModel;

public class HMMPathParser implements Serializable {
	
	public static int numstates = 6;
	public final FullHiddenMarkovModel hmm;
	
	public HMMPathParser() {
		FullHiddenMarkovModel.setRandomSeed(0);
		this.hmm = FullHiddenMarkovModel.random(numstates, 256);
		
		// state set "1" is a path segment
		int[] extractStates = new int[] { 0, 1 };
		int[] otherStates = new int[] { 2, 3, 4, 5 };
		hmm.defineStateSet(1, extractStates);
		hmm.defineStateSet(0, otherStates);
	}
	
	public final static int STATE_SET_EXTRACT = 1;
	public final static int STATE_SET_OTHER = 0;
	
	public int[] parse( String path ) {

		int[] obs = pathToObservations(path);
		
		int[] stateEst = hmm.inferMaximumLikelihoodStates(obs);
		return stateEst;
		
	}
	
	private int[] pathToObservations( String path ) {
		// Turn strings into sequences of integer observations
		char[] chars = path.toCharArray();
		int[] obs = new int[chars.length];
		for( int k = 0; k < chars.length; ++k )
			obs[k] = chars[k];
		return obs;
	}

	public void train(ArrayList<String> trainingPaths,
			ArrayList<int[]> stateSets) {
		
		ArrayList<int[]> trainingInts = new ArrayList<int[]>( trainingPaths.size() );
		for( String path : trainingPaths ) 
			trainingInts.add( pathToObservations( path ) );
		hmm.singleBaumWelch( trainingInts, stateSets );
		
	}
	
}
