package com.flyingsloth.financial.data;

import java.io.IOException;
import java.sql.Array;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import java.sql.Connection;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;

import java.sql.PreparedStatement;

import org.apache.commons.lang3.ArrayUtils;

public class JDBCDataSource extends AssetHistorySource {

	static{
		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			throw new RuntimeException("MySQL Connector/J (MySQL JDBC driver) not found", e);
		}
	}
		
	void createTables() throws SQLException{
		Connection con = DriverManager.getConnection(url,login,passwd);
		Statement stmt = con.createStatement();
		
		// Create price history table
		String createcmd = "CREATE  TABLE `" + this.table + "` (" + 
		  AssetHistory.DATA_COL_DESC + " ," +
		  "PRIMARY KEY (`symbol`,`date`) );";
		stmt.executeUpdate( createcmd );
		
		con.close();
	}

	private static final String url = "jdbc:mysql://127.0.0.1:3306/assets";
	private static final String login = "investbot";
	private static final String passwd = "99baNAna";
	private static final String default_table = "AssetHistory";
	private final String table;
	
	private Connection dbconnection;
	
	public JDBCDataSource( ) throws SQLException {	
		this(default_table);
	}
	
	public JDBCDataSource( String table ) throws SQLException {
		this.table = table;
		dbconnection = DriverManager.getConnection(url,login,passwd);
		String repquest = "?"; // First one is stock symbol
		for( int k = 0; k < AssetHistory.NUM_DATA_COLS; ++k )
			repquest = repquest + ",?";	
		// Note, REPLACE command (MySQL special command) is like an insert that deletes any existing row with matching key
		String insert_cmd = "REPLACE INTO " + table + " values(" + repquest + ")";
		insert_statement = dbconnection.prepareStatement(insert_cmd);
		String update_cmd = "update " + table + " set open=?, high=?, low=?, close=?, volume=?, dividend=? WHERE symbol=? && date=?";
		update_statement = dbconnection.prepareStatement(update_cmd);
		String select_cmd = "select " + AssetHistory.DATA_COL_NAMES + " from " + table + " WHERE symbol = ? ORDER BY date";
		select_statement = dbconnection.prepareStatement(select_cmd);
		String select_where_cmd = "select " + AssetHistory.DATA_COL_NAMES + " from " + table + " WHERE symbol = ? AND date>=? AND date<=? ORDER BY date";
		select_where_statement = dbconnection.prepareStatement(select_where_cmd);
		String count_cmd = "select COUNT(symbol) from " + table + " WHERE symbol = ?";
		count_statement = dbconnection.prepareStatement(count_cmd);
		String count_where_cmd = "select COUNT(symbol) from " + table + " WHERE symbol = ? AND date>=? AND date<=?";
		count_where_statement = dbconnection.prepareStatement(count_where_cmd);
		String isentry_cmd = "select COUNT(symbol) from " + table + " WHERE symbol = ? AND date = ?";	
		isentry_statement = dbconnection.prepareStatement(isentry_cmd);
		String updatesplit_cmd = "update " + table + " set split = ? WHERE symbol = ? AND date = ?";
		updatesplit_statement = dbconnection.prepareStatement(updatesplit_cmd);
		String insertsplit_cmd = "insert into " + table + " (symbol,date,split) VALUES (?,?,?)";
		insertsplit_statement = dbconnection.prepareStatement(insertsplit_cmd);
		
		// Wealth factor = split_tomorrow*cprice_tomorrow/cprice_today*( 1 + dividend_tomorrow/cprice_tomorrow )
		String wealthfactor_cmd = 
			"SELECT tableA.date as factor_date, tableB.split*tableB.close/tableA.close*(1+tableB.dividend/tableB.close) as factor FROM (select @cntA := @cntA+1 as daycnt, AssetHistory.* from AssetHistory where symbol=? ORDER BY date ASC) as tableA, (select @cntB := @cntB+1 as daycnt, AssetHistory.* from AssetHistory where symbol=? ORDER BY date ASC) as tableB where tableB.daycnt=tableA.daycnt+1 AND tableA.date>=? AND tableA.date<=?;";
		wealth_factor_statement = dbconnection.prepareStatement(wealthfactor_cmd);
		wealth_factor_prestatement = dbconnection.prepareStatement( "SET @cntA=0, @cntB=0;" );
		
		
		yield_metric_prestatement = dbconnection.prepareStatement( "SET @csum := 0;" );
		String yieldmetric_cmd = "SELECT yieldres.yieldsum/priceres.latestprice FROM (SELECT SUM(assethist.dividend*share_equiv.today_share_equiv) as yieldsum FROM (SELECT * FROM AssetHistory WHERE symbol=? AND date>=?) as assethist, (SELECT date, EXP( @csum := @csum - LOG(split) ) as today_share_equiv FROM AssetHistory WHERE symbol=?  AND date>=? ORDER BY date DESC) as share_equiv WHERE assethist.date=share_equiv.date) as yieldres, (SELECT prices.close as latestprice FROM (SELECT * FROM AssetHistory WHERE symbol=? AND date>=?) as prices, (SELECT MAX(date) as maxdate FROM AssetHistory WHERE symbol=? AND date>=?) as maxres WHERE prices.date=maxres.maxdate) as priceres;";
		yield_metric_statement = dbconnection.prepareStatement(yieldmetric_cmd);
		// Arguments
		//   1 - symbol string
		//   2 - Date to start counting dividends at
		//   3 - symbol string
		//   4 - Date to start counting dividends at
		//   5 - symbol string
		//   6 - Date to start counting dividends at
		//   7 - symbol string
		//   8 - Date to start counting dividends at
		
		count_close_statement = dbconnection.prepareStatement( "SELECT COUNT(close) FROM AssetHistory WHERE symbol=?;");
		
	}
	
	private PreparedStatement insert_statement;
	private PreparedStatement update_statement;
	private PreparedStatement select_statement;
	private PreparedStatement select_where_statement;
	/**
	 *  Count number of entries a given stock symbol has
	 */
	private PreparedStatement count_statement;
	private PreparedStatement count_where_statement;
	
	
	
	/**
	 * Turn floats that are NaN into null values for SQL
	 * @throws SQLException 
	 */
	private static void setFloat( PreparedStatement s, int paramindex, float v ) throws SQLException {
		if( Float.isNaN(v) )
			s.setNull(paramindex, java.sql.Types.FLOAT );
		else
			s.setFloat(paramindex, v );
	}
	
	private static void setDouble( PreparedStatement s, int paramindex, double v ) throws SQLException {
		if( Double.isNaN(v) )
			s.setNull(paramindex, java.sql.Types.DOUBLE );
		else
			s.setDouble(paramindex, v );
	}

	public boolean add( AssetHistory o ) throws SQLException {
		o.normalize();
		insert_statement.setString( 1, o.symbol );
		for( int k = 0; k < o.date.length; ++k )
		{
			insert_statement.setDate( 2, new java.sql.Date( o.date[k].getTime() ) );
			// SQL can't handle Floats that are NaN
			setFloat( insert_statement, 3, o.open[k] );
			setFloat( insert_statement, 4, o.high[k] );
			setFloat( insert_statement, 5, o.low[k] );
			setFloat( insert_statement, 6, o.close[k] );
			insert_statement.setInt( 7, o.volume[k] );
			setDouble( insert_statement, 8, o.getDividend(k) );	
			setDouble( insert_statement, 9, o.split[k] );
			insert_statement.executeUpdate();
		}
		return true;
	}
	
	public void update( AssetHistory o ) throws SQLException {
		o.normalize();
		update_statement.setString( 8, o.symbol );
		for( int k = 0; k < o.date.length; ++k )
		{
			update_statement.setDate( 9, new java.sql.Date( o.date[k].getTime() ) );
			// SQL can't handle Floats that are NaN
			setFloat( update_statement, 1, o.open[k] );
			setFloat( update_statement, 2, o.high[k] );
			setFloat( update_statement, 3, o.low[k] );
			setFloat( update_statement, 4, o.close[k] );
			update_statement.setInt( 5, o.volume[k] );
			setDouble( update_statement, 6, o.getDividend(k) );	
			update_statement.executeUpdate();
		}
	}

	public void clear() throws SQLException {
		Statement stmt = dbconnection.createStatement();
		stmt.executeUpdate("DELETE FROM " + table);
	}
	
	@Override
	public AssetHistory getAsset(String symbol) throws NumberFormatException,
			ParseException, IOException, SQLException {

		AssetHistory res = new AssetHistory();
		res.symbol = symbol;
		
		// How much space to save for results
		count_statement.setString( 1, symbol );
		ResultSet result = count_statement.executeQuery();
		result.next();
		res.allocateArrays( result.getInt(1) );		
		
//		// Intermediate storage for results
//		ArrayList<Date> date = new ArrayList<Date>(1024);
//		ArrayList<Float> open = new ArrayList<Float>(1024);
//		ArrayList<Float> high = new ArrayList<Float>(1024);
//		ArrayList<Float> low = new ArrayList<Float>(1024);
//		ArrayList<Float> close = new ArrayList<Float>(1024);
//		ArrayList<Integer> volume = new ArrayList<Integer>(1024);
//		ArrayList<Double> dividend = new ArrayList<Double>(1024);
//		ArrayList<Double> split = new ArrayList<Double>(1024);		
		
		// Get rows from database
		select_statement.setString( 1, symbol );
		result = select_statement.executeQuery();
		int k = 0;
		while( result.next() )
		{
			res.date[k] = result.getDate(1);
			res.open[k] = result.getFloat(2);
			res.high[k] = result.getFloat(3);
			res.low[k] = result.getFloat(4);
			res.close[k] = result.getFloat(5);
			res.volume[k] = result.getInt(6);
			//res.dividends[k] = result.getDouble(7);
			res.setDividend(k, result.getDouble(7));
			res.split[k] = result.getDouble(8);
		    ++k;
			
//			date.add(result.getDate(1));
//			open.add(result.getFloat(2));
//			high.add(result.getFloat(3));
//			low.add(result.getFloat(4));
//			close.add(result.getFloat(5));
//			volume.add(result.getInt(6));
//			dividend.add(result.getDouble(7));
//			split.add(result.getDouble(8));
		}
		
//		res.date = date.toArray( new Date[0] );
//		res.open = ArrayUtils.toPrimitive(open.toArray(new Float[0]));
//		res.high = ArrayUtils.toPrimitive(high.toArray(new Float[0]));
//		res.low = ArrayUtils.toPrimitive(low.toArray(new Float[0]));
//		res.close = ArrayUtils.toPrimitive(close.toArray(new Float[0]));
//		res.volume = ArrayUtils.toPrimitive(volume.toArray(new Integer[0]));
//		res.dividends = ArrayUtils.toPrimitive(dividend.toArray(new Double[0]));
//		res.split = ArrayUtils.toPrimitive(split.toArray(new Double[0]));
		
		return res;
	}
	
	@Override
	public AssetHistory getAsset(String symbol, Date start, Date end) throws NumberFormatException,
			ParseException, IOException, SQLException {

		AssetHistory res = new AssetHistory();
		res.symbol = symbol;
		
		// How much space to save for results
		count_where_statement.setString( 1, symbol );
		count_where_statement.setDate(2, new java.sql.Date( start.getTime() ) );
		count_where_statement.setDate(3, new java.sql.Date( end.getTime() ) );
		
		ResultSet result = count_where_statement.executeQuery();
		result.next();
		res.allocateArrays( result.getInt(1) );		
		

		
		// Get rows from database
		select_where_statement.setString( 1, symbol );
		select_where_statement.setDate(2, new java.sql.Date( start.getTime() ) );
		select_where_statement.setDate(3, new java.sql.Date( end.getTime() ) );
		result = select_where_statement.executeQuery();
		int k = 0;
		while( result.next() )
		{
			res.date[k] = result.getDate(1);
			res.open[k] = result.getFloat(2);
			res.high[k] = result.getFloat(3);
			res.low[k] = result.getFloat(4);
			res.close[k] = result.getFloat(5);
			res.volume[k] = result.getInt(6);
			//res.dividends[k] = result.getDouble(7);
			res.setDividend(k, result.getDouble(7));
			res.split[k] = result.getDouble(8);
		    ++k;
		}
		
		return res;
	}
	
	public String[] getSymbols() throws SQLException {
		ArrayList<String> res = new ArrayList<String>(30000);
		Statement stmt = this.dbconnection.createStatement();		
		ResultSet syms = stmt.executeQuery("SELECT DISTINCT symbol FROM " + this.table + ";");
		while( syms.next() )
			res.add( syms.getString(1) );
		
		return res.toArray(new String[0]);
	} 
	
	/**
	 *  Determine whether there is an entry for the given stock and date
	 */
	private PreparedStatement isentry_statement;	
	
	public boolean hasEntry( String symbol, Date date ) throws SQLException {
		isentry_statement.setString( 1, symbol );
		isentry_statement.setDate( 2, new java.sql.Date( date.getTime() ) );
		ResultSet res = isentry_statement.executeQuery();
		res.next();
		return (res.getInt(1)>0);
	}
	
	/**
	 * Update the split field on an existing entry
	 */
	private PreparedStatement updatesplit_statement;
	
	/**
	 * Insert a new field with only symbol, date, split
	 */
	private PreparedStatement insertsplit_statement;
	
	public void setSplits( String symbol, Collection<DateDouble> splits ) throws SQLException {
		updatesplit_statement.setString(2, symbol);	
		insertsplit_statement.setString(1, symbol);
		for( DateDouble split : splits )
		{
			if( hasEntry(symbol,split.date) )
			{
				updatesplit_statement.setDate(3, new java.sql.Date( split.date.getTime() ) );
				updatesplit_statement.setDouble(1, split.value);
				updatesplit_statement.executeUpdate();
			}
			else
			{
//				System.err.println( "Warning: ignoring split for " + symbol + " at " + split.date );
				insertsplit_statement.setDate(2, new java.sql.Date( split.date.getTime() ) );
				insertsplit_statement.setDouble(3, split.value);
				insertsplit_statement.execute();
			}
		}
	}
	
	private PreparedStatement wealth_factor_prestatement;
	private PreparedStatement wealth_factor_statement;
	public DateDoubleList wealthFactor( String symbol, Date start, Date end ) throws SQLException {
		wealth_factor_statement.setString( 1, symbol );
		wealth_factor_statement.setString( 2, symbol );
		wealth_factor_statement.setDate( 3, new java.sql.Date( start.getTime() ) );
		wealth_factor_statement.setDate( 4, new java.sql.Date( end.getTime() ) );
		wealth_factor_prestatement.execute();
		ResultSet factors = wealth_factor_statement.executeQuery();
		ArrayList<DateDouble> results = new ArrayList<DateDouble>( (int)((end.getTime()-start.getTime())/(1000.0*60.0*60.0*24.0)) );
		while( factors.next() )
		{
			results.add( new DateDouble( factors.getDate(1), factors.getDouble(2) ) );
		}
		return new DateDoubleList( results );
	}
	
	private PreparedStatement yield_metric_prestatement;
	private PreparedStatement yield_metric_statement;
	/**
	 * Returns the sum of dividends from the start date returned by a current single share equivalent,
	 * divided by the current closing price of such a share.   
	 * @throws SQLException 
	 */
	public double yieldMetric( String symbol, Date start ) throws SQLException {
		yield_metric_statement.setString(1, symbol);
		yield_metric_statement.setString(3, symbol);
		yield_metric_statement.setString(5, symbol);
		yield_metric_statement.setString(7, symbol);
		yield_metric_statement.setDate( 2, new java.sql.Date( start.getTime() ) );
		yield_metric_statement.setDate( 4, new java.sql.Date( start.getTime() ) );
		yield_metric_statement.setDate( 6, new java.sql.Date( start.getTime() ) );
		yield_metric_statement.setDate( 8, new java.sql.Date( start.getTime() ) );
		yield_metric_prestatement.execute();
		ResultSet res = yield_metric_statement.executeQuery();
		res.next();
		return res.getDouble(1);
	}
	// Note: Looks like doing this calculation in MATLAB is actually faster.  See yieldMetric.m

	private PreparedStatement count_close_statement;
	/**
	 * How many of the entries for the given symbol have non-null closing prices.  
	 * Useful for identifying symbols for which we have failed to obtain price data.
	 */
	public double closeCount( String symbol ) throws SQLException
	{
		count_close_statement.setString(1, symbol);
		ResultSet res = count_close_statement.executeQuery();
		return res.getDouble(1);
	}
	
}
