package edu.mit.ll.williams.hmm.test;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Arrays;

import org.jblas.DoubleMatrix;
import org.junit.Test;
import static org.junit.Assert.*;

import edu.mit.ll.williams.hmm.FullHiddenMarkovModel;

public class TestFullHiddenMarkovModel extends FullHiddenMarkovModel {

	private static final long serialVersionUID = -3902410576847131882L;

	public TestFullHiddenMarkovModel() {
		super(2,2);
		initialize();
	}
	
	private void initialize() {
		this.initialStateProbabilities.copy( new DoubleMatrix( new double[] { 0.5, 0.5 } ) );
		this.transitionProbabilities.copy( new DoubleMatrix( new double[][] { {0.7, 0.3}, {0.3, 0.7} } ) );
		this.observationProbabilities.copy( new DoubleMatrix( new double[][] { {0.9, 0.1}, {0.2, 0.8} } ));		
	}
	
	@Test
	public void testInferStateDistributions() {
		DoubleMatrix pState = inferStateDistributions( new int[] { 0, 0, 1, 0, 0 }, true );
		System.out.println( pState );
		//assertArrayEquals( new double[] {0.6469, 0.3531}, pState.getColumn(0).data, 0.0001 );
		assertArrayEquals( new double[] {0.8673, 0.1327}, pState.getColumn(0).data, 0.0001 );
		assertArrayEquals( new double[] {0.8204, 0.1796}, pState.getColumn(1).data, 0.0001 );
		assertArrayEquals( new double[] {0.3075, 0.6925}, pState.getColumn(2).data, 0.0001 );
		assertArrayEquals( new double[] {0.8204, 0.1796}, pState.getColumn(3).data, 0.0001 );
		assertArrayEquals( new double[] {0.8673, 0.1327}, pState.getColumn(4).data, 0.0001 );
	}
	
	@Test
	public void testBaumWelch() {
		ArrayList<int[]> corpus = new ArrayList<int[]>();
		corpus.add( new int[]{ 0, 0, 1, 0, 0 } );
		corpus.add( new int[]{ 1, 1, 0, 1, 1, 1, 1, 0, 0 } );
		corpus.add( new int[]{ 1, 0, 0, 0 } );
		singleBaumWelch( corpus );
		System.out.println(this);
		assertArrayEquals( new double[]{ 0.37536055679973, 0.62463944320027 }, this.initialStateProbabilities.data, 1e-6 );
		assertArrayEquals( new double[]{ 0.901446496969686, 0.206995603475245, 0.0985535030303143, 0.793004396524755 }, this.observationProbabilities.data, 1e-6 );
		assertArrayEquals( new double[]{ 0.756542757684001, 0.355720715367085, 0.243457242315999, 0.644279284632915 }, this.transitionProbabilities.data, 1e-6 );
	}
	
	@Test
	public void testExpectedTransitionCount() {
		int[] observations = new int[] { 0, 0, 1, 0, 0 };
		DoubleMatrix fwd = this.inferForwardStateDistributions(observations, true);
		DoubleMatrix bwd = this.inferBackwardStateDistributions(observations);
		DoubleMatrix transcnt = expectedTransitionCount( observations, fwd, bwd );
		System.out.println( transcnt );
		assertArrayEquals( new double[]{ 2.08018618865915, 0.735474384170303, 0.735474384170303, 0.448865043000245 }, transcnt.data, 1e-4 );
	}
	
	@Test
	public void testConstraints() {
		
		this.initialize();
		ArrayList<int[]> corpus = new ArrayList<int[]>();
		ArrayList<int[]> constraints = new ArrayList<int[]>();
		corpus.add(      new int[]{ 0, 0, 1, 0, 0 } );
		constraints.add( new int[]{ 1, 0, 0, 1, 0 } );
		corpus.add(      new int[]{ 1, 1, 0, 1, 1, 1, 1, 0, 0 } );
		constraints.add( new int[]{ 0, 0, 0, 2, 0, 0, 0, 0, 0 } );
		corpus.add(      new int[]{ 1, 0, 0, 0 } );
		constraints.add( new int[]{ 0, 0, 0, 0 } );
		singleBaumWelch( corpus, constraints );
		System.out.println(this);
		assertArrayEquals( new double[]{ 0.37536055679973, 0.62463944320027 }, this.initialStateProbabilities.data, 1e-6 );
		assertArrayEquals( new double[]{ 0.901446496969686, 0.206995603475245, 0.0985535030303143, 0.793004396524755 }, this.observationProbabilities.data, 1e-6 );
		assertArrayEquals( new double[]{ 0.756542757684001, 0.355720715367085, 0.243457242315999, 0.644279284632915 }, this.transitionProbabilities.data, 1e-6 );
		
		this.defineStateSet( 2, new int[]{ 1 } ); // state set "2" means state index 1
		
		this.initialize();
//		ArrayList<int[]> corpus = new ArrayList<int[]>();
//		ArrayList<int[]> constraints = new ArrayList<int[]>();
//		corpus.add(      new int[]{ 0, 0, 1, 0, 0 } );
//		constraints.add( new int[]{ 1, 0, 0, 1, 0 } );
//		corpus.add(      new int[]{ 1, 1, 0, 1, 1, 1, 1, 0, 0 } );
//		constraints.add( new int[]{ 0, 0, 0, 2, 0, 0, 0, 0, 0 } );
//		corpus.add(      new int[]{ 1, 0, 0, 0 } );
//		constraints.add( new int[]{ 0, 0, 0, 0 } );
		singleBaumWelch( corpus, constraints );
		System.out.println(this);
//		assertArrayEquals( new double[]{ 0.37536055679973, 0.62463944320027 }, this.initialStateProbabilities.data, 1e-6 );
//		assertArrayEquals( new double[]{ 0.901446496969686, 0.206995603475245, 0.0985535030303143, 0.793004396524755 }, this.observationProbabilities.data, 1e-6 );
//		assertArrayEquals( new double[]{ 0.756542757684001, 0.355720715367085, 0.243457242315999, 0.644279284632915 }, this.transitionProbabilities.data, 1e-6 );		
		
	}
	
	public static void main( String[] args ) throws FileNotFoundException, IOException {
		// Try to train model for extracting portions of path	
		HMMPathParser.numstates = 6;
		HMMPathParser hmm = new HMMPathParser();
		System.out.println("Initial HMM:");
		System.out.println(hmm.hmm);
		// state set "1" is a path segment
		int[] extractStates = new int[] { 0, 1 };
		int[] otherStates = new int[] { 2, 3, 4, 5 };
		hmm.defineStateSet(1, extractStates);
		hmm.defineStateSet(0, otherStates);
		
		ArrayList<String> trainingStrings = new ArrayList<String>();
		ArrayList<int[]> stateSets = new ArrayList<int[]>();
		
		trainingStrings.add( "/path/to/file" );
//		                          "/ p a t h / t o / f i l e"
		stateSets.add( new int[] { 0,1,1,1,1,0,1,1,0,1,1,1,1 } );
		
		trainingStrings.add( "somewhere/over/the.rainbow" );
//                                "s o m e w h e r e / o v e r / t h e . r a i n b o w"		
		stateSets.add( new int[] { 1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1 } );
		
		trainingStrings.add( "'/bluebirds/fly'" );
//		                          "' / b l u e b i r d s / f l y '"
		stateSets.add( new int[] { 0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0 } );
		
		trainingStrings.add( "/Users/ri18384/Desktop/bob\\\'s\\ file" );
//		                           / U s e r s / r i 1 8 3 8 4 / D e s k t o p / b o b \ ' s \   f i l e 
		stateSets.add( new int[] { 0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 } );
		
		// Turn strings into sequences of integer observations
		ArrayList<int[]> trainingInts = new ArrayList<int[]>( trainingStrings.size() );
		for( String str : trainingStrings ) {
			char[] chars = str.toCharArray();
			int[] ints = new int[chars.length];
			for( int k = 0; k < chars.length; ++k )
				ints[k] = chars[k];
			trainingInts.add(ints);
		}
		
		// Train Model
		long tic = System.currentTimeMillis();
		for( int k = 0; k < 20; ++k ) {
			hmm.singleBaumWelch( trainingInts, stateSets );
			System.out.println(hmm);
		}
		long toc = System.currentTimeMillis();
		System.out.println( "time elapsed: " + (toc-tic) + " ms" );
		
		System.out.println(hmm);

		// Save resulting HMM to disk
		ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream( "pathHmm.bin"  ) );
		out.writeObject(hmm);
		out.close();
		
		// Has it learned all the training examples?
		for ( int k = 0; k < trainingStrings.size(); ++k ) {
			int[] observations = trainingInts.get(k);
			int[] stateEst = hmm.inferMaximumLikelihoodStates(observations);
			
			System.out.println( Arrays.toString( trainingStrings.get(k).toCharArray() ) );
			System.out.println( Arrays.toString(stateEst) );
			System.out.println();
		}
		
		// How does it do on paths it hasn't seen before?
		String newPath = "/Users/ri18384/Documents/NICS/repos/crowdsourcing/textFeatureExtraction/HMM/hmmtwinkle.m"
		int[] stateEst = hmm.inferMaximumLikelihoodStates(observations)
	}
	
}
